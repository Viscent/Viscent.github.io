<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Viscent's Blog]]></title>
  <link href="http://viscent.github.io/atom.xml" rel="self"/>
  <link href="http://viscent.github.io/"/>
  <updated>2014-11-29T20:02:40+08:00</updated>
  <id>http://viscent.github.io/</id>
  <author>
    <name><![CDATA[Viscent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java多线程编程模式实战指南：Active Object模式（上）]]></title>
    <link href="http://viscent.github.io/blog/2014/11/29/javaduo-xian-cheng-bian-cheng-mo-shi-shi-zhan-zhi-nan-:active-objectmo-shi-(shang-)/"/>
    <updated>2014-11-29T17:53:50+08:00</updated>
    <id>http://viscent.github.io/blog/2014/11/29/javaduo-xian-cheng-bian-cheng-mo-shi-shi-zhan-zhi-nan-:active-objectmo-shi-(shang-)</id>
    <content type="html"><![CDATA[<p>Active Object模式简介</p>

<p>Active Object模式是一种异步编程模式。它通过对方法的调用与方法的执行进行解耦来提高并发性。若以任务的概念来说，Active Object模式的核心则是它允许任务的提交（相当于对异步方法的调用）和任务的执行（相当于异步方法的真正执行）分离。这有点类似于System.gc()这个方法：客户端代码调用完gc()后，一个进行垃圾回收的任务被提交，但此时JVM并不一定进行了垃圾回收，而可能是在gc()方法调用返回后的某段时间才开始执行任务——回收垃圾。我们知道，System.gc()的调用方代码是运行在自己的线程上（通常是main线程派生的子线程），而JVM的垃圾回收这个动作则由专门的线程（垃圾回收线程）来执行的。换言之，System.gc()这个方法所代表的动作（其所定义的功能）的调用方和执行方是运行在不同的线程中的，从而提高了并发性。</p>

<p>再进一步介绍Active Object模式，我们可先简单地将其核心理解为一个名为ActiveObject的类，该类对外暴露了一些异步方法，如图1所示。</p>

<p>图 1. ActiveObject对象示例</p>
]]></content>
  </entry>
  
</feed>
